<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>物理演算ブロック崩し</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a202c;
            color: #e2e8f0;
            margin: 0;
            overflow: hidden;
            flex-direction: column;
            gap: 20px;
        }
        .main-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            border-radius: 16px;
            background-color: #2d3748;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            position: relative;
        }
        canvas {
            background-color: #2d3748;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            display: block;
            outline: none;
        }
        h1 {
            color: #63b3ed;
            font-size: 2.25rem;
            font-weight: bold;
        }
        *:focus {
            outline: none;
        }
        .editor-panel {
            width: 300px;
            background-color: #2d3748;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .hidden {
            display: none;
        }
        .editor-panel h2 {
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
        }
        .editor-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .editor-controls button, .editor-controls label {
            background-color: #4c51bf;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            text-align: center;
        }
        .editor-controls button:hover, .editor-controls label:hover {
            background-color: #667eea;
        }
        .block-picker {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 15px;
            justify-content: center;
        }
        .block-tile {
            width: 25px;
            height: 25px;
            border-radius: 4px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.1s, border-color 0.2s;
        }
        .block-tile:hover {
            transform: scale(1.1);
        }
        .block-tile.selected {
            border-color: #e2e8f0;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <h1>物理演算ブロック崩し</h1>
    <div class="main-container">
        <div class="game-container">
            <canvas id="gameCanvas" tabindex="0"></canvas>
        </div>
        <div id="editorPanel" class="editor-panel hidden">
            <h2>ステージエディタ</h2>
            <div class="editor-controls">
                <p class="text-center text-sm mb-2">選択中のタイルでクリック＆ドラッグしてブロックを配置/削除</p>
                <div class="block-picker" id="editorBlockPicker"></div>
                <button id="saveStageToFileButton">ステージをファイルに保存</button>
                <label class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded transition-colors duration-200 cursor-pointer text-center">
                    ファイルからステージを読み込み
                    <input type="file" id="loadStageFromFileInput" class="hidden" accept=".json">
                </label>
                <button id="exitEditorButton">ゲームモードに戻る</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const editorPanel = document.getElementById('editorPanel');
        const editorBlockPicker = document.getElementById('editorBlockPicker');
        const saveStageToFileButton = document.getElementById('saveStageToFileButton');
        const loadStageFromFileInput = document.getElementById('loadStageFromFileInput');
        const exitEditorButton = document.getElementById('exitEditorButton');

        document.addEventListener('DOMContentLoaded', () => {
            canvas.focus();
            exitEditorButton.addEventListener('click', toggleEditorMode);
            saveStageToFileButton.addEventListener('click', saveStageToFile);
            loadStageFromFileInput.addEventListener('change', loadStageFromFile);
        });
        
        document.addEventListener('keydown', async (e) => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key) || e.code === 'Space') {
                e.preventDefault();
            }

            if (e.metaKey && (e.key === ' ' || e.code === 'Space')) {
                e.preventDefault();
            }

            if (e.key === 'E') {
                toggleEditorMode();
            }
            if (!gameStarted && !editorMode && !isTransitioningToNextStage && (e.key === 'ArrowUp')) {
                if (lives > 0) {
                    if (blocks.length === BLOCK_COLUMN_COUNT * BLOCK_ROW_COUNT) {
                        startGame();
                    }
                }
                else {
                    await restartGame();
                }
            }
        });

        const CANVAS_WIDTH = 600;
        const CANVAS_HEIGHT = 450;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        const PADDLE_HEIGHT = 20;
        const PADDLE_WIDTH_INITIAL = 100;
        const PADDLE_SPEED_INITIAL = 10;
        const PADDLE_SPEED_MAX = 20;

        const BALL_RADIUS = 7;
        const BALL_SPEED_INITIAL = 5.0;
        const MAX_BALL_SPEED = 12.0; // 修正案を反映
        const GRAVITY = 0.04;
        const DAMPING_FACTOR = 0.99;
        const BALL_MAX_COUNT = 40;
        
        const BLOCK_ROW_COUNT = 16;
        const BLOCK_COLUMN_COUNT = 10;
        const BLOCK_WIDTH = CANVAS_WIDTH / BLOCK_COLUMN_COUNT;
        const BLOCK_HEIGHT = 20;
        const BLOCK_OFFSET_TOP = 50;
        const BLOCK_OFFSET_LEFT = 0;
        
        const POSITIVE_BLOCK_FORCE = 1.0; // 修正案を反映
        const POSITIVE_BLOCK_RANGE_SQ = (BLOCK_WIDTH * 8) * (BLOCK_WIDTH * 8); // 修正案を反映
        const ELECTROMAGNETIC_FORCE_CONSTANT = 0;
        
        const BALL_COLORS = ['#3182ce', '#63b3ed', '#a0aec0', '#e2e8f0', '#fbd38d', '#fc8181', '#e53e3e'];

        const POWERUP_SIZE = 20;
        const POWERUP_SPEED = 2;

        const BASE_COLORS = ['#e53e3e', '#dd6b20', '#d69e2e', '#38a169', '#3182ce', '#4c51bf', '#9f7aea'];
        const COLOR_PALETTE = [];

        function lightenColor(color, percent) {
            const f = parseInt(color.slice(1), 16),
                t = percent < 0 ? 0 : 255,
                p = percent < 0 ? percent * -1 : percent,
                R = f >> 16,
                G = (f >> 8) & 0x00ff,
                B = f & 0x0000ff;
            return "#" +
                (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 +
                (Math.round((t - G) * p) + G) * 0x100 +
                (Math.round((t - B) * p) + B))
                .toString(16)
                .slice(1);
        }

        BASE_COLORS.forEach(baseColor => {
            COLOR_PALETTE.push([
                baseColor,
                lightenColor(baseColor, 0.4),
                lightenColor(baseColor, 0.7)
            ]);
        });

        const TOTAL_STAGES = 5;
        let currentStageNumber = 1;
        
        const speedIncrement = (MAX_BALL_SPEED - BALL_SPEED_INITIAL) / 10; // パドル衝突時の加速量
        const collisionSpeedIncrement = speedIncrement / 4; // 壁やブロック衝突時の加速量

        let paddle = {
            x: (CANVAS_WIDTH - PADDLE_WIDTH_INITIAL) / 2,
            y: CANVAS_HEIGHT - PADDLE_HEIGHT - 30,
            width: PADDLE_WIDTH_INITIAL,
            height: PADDLE_HEIGHT,
            dx: 0,
            speed: PADDLE_SPEED_INITIAL
        };

        let balls = [];
        let blocks = [];
        let powerups = [];
        let score = 0;
        let lives = 3;
        let gameStarted = false;
        let editorMode = false;
        let isDragging = false;
        let hasDragged = false;
        let startDragPos = { x: 0, y: 0 };
        let endDragPos = { x: 0, y: 0 };
        let selectedBlock = {
            status: 1,
            hits: 1,
            isIndestructible: false,
            isChargeBlock: false,
            chargeChange: 0,
            isElectricForceBlock: false,
            electricCharge: 0,
            colorIndex: 0
        };
        let isTransitioningToNextStage = false;

        let rightPressed = false;
        let leftPressed = false;
        let lastTouchX = 0;
        let touchActive = false;
        let mouseTargetX = null;
        
        let unbreakableBlockImage = new Image();
        unbreakableBlockImage.src = 'unbreakable_block.png';
        let posChargeAddBlockImage = new Image();
        posChargeAddBlockImage.src = 'pos_charge_add_block.png';
        let negChargeAddBlockImage = new Image();
        negChargeAddBlockImage.src = 'neg_charge_add_block.png';
        let positiveBlockImage = new Image();
        positiveBlockImage.src = 'positive_block.png';
        let negativeBlockImage = new Image();
        negativeBlockImage.src = 'negative_block.png';


        function activateGameEventListeners() {
            canvas.addEventListener('keydown', keyDownHandler, false);
            canvas.addEventListener('keyup', keyUpHandler, false);
            canvas.addEventListener('mousemove', mouseMoveHandler, false);
            canvas.addEventListener('click', handleCanvasClick, false);
            canvas.addEventListener('touchstart', touchStartHandler, false);
            canvas.addEventListener('touchmove', touchMoveHandler, false);
            canvas.addEventListener('touchend', touchEndHandler, false);
        }

        function activateEditorEventListeners() {
            canvas.addEventListener('mousedown', editorMouseDownHandler);
            canvas.addEventListener('mouseup', editorMouseUpHandler);
            canvas.addEventListener('mousemove', editorMouseMoveHandler);
        }

        function removeAllEventListeners() {
            canvas.removeEventListener('keydown', keyDownHandler);
            canvas.removeEventListener('keyup', keyUpHandler);
            canvas.removeEventListener('mousemove', mouseMoveHandler);
            canvas.removeEventListener('click', handleCanvasClick);
            canvas.removeEventListener('touchstart', touchStartHandler);
            canvas.removeEventListener('touchmove', touchMoveHandler);
            canvas.removeEventListener('touchend', touchEndHandler);
            canvas.removeEventListener('mousedown', editorMouseDownHandler);
            canvas.removeEventListener('mouseup', editorMouseUpHandler);
            canvas.removeEventListener('mousemove', editorMouseMoveHandler);
        }

        function setupEditorBlockPicker() {
            editorBlockPicker.innerHTML = '';
            
            let deleteTile = document.createElement('div');
            deleteTile.className = 'block-tile';
            deleteTile.style.backgroundColor = '#1a202c';
            deleteTile.setAttribute('data-status', '0');
            deleteTile.addEventListener('click', () => selectEditorBlock({ status: 0 }, deleteTile));
            editorBlockPicker.appendChild(deleteTile);

            let unbreakableTile = document.createElement('div');
            unbreakableTile.className = 'block-tile';
            unbreakableTile.style.backgroundColor = '#A9A9A9';
            unbreakableTile.setAttribute('data-hits', '100');
            unbreakableTile.setAttribute('data-color-index', '-1');
            unbreakableTile.setAttribute('data-status', '1');
            unbreakableTile.addEventListener('click', () => selectEditorBlock({ status: 1, hits: 100, isIndestructible: true, isChargeBlock: false, chargeChange: 0, isElectricForceBlock: false, electricCharge: 0, colorIndex: -1 }, unbreakableTile));
            editorBlockPicker.appendChild(unbreakableTile);

            let posChargeTile = document.createElement('div');
            posChargeTile.className = 'block-tile';
            posChargeTile.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
            posChargeTile.addEventListener('click', () => selectEditorBlock({ status: 1, hits: 1, isIndestructible: true, isChargeBlock: true, chargeChange: 1, isElectricForceBlock: false, electricCharge: 0 }, posChargeTile));
            editorBlockPicker.appendChild(posChargeTile);

            let negChargeTile = document.createElement('div');
            negChargeTile.className = 'block-tile';
            negChargeTile.style.backgroundColor = 'rgba(0, 0, 255, 0.5)';
            negChargeTile.addEventListener('click', () => selectEditorBlock({ status: 1, hits: 1, isIndestructible: true, isChargeBlock: true, chargeChange: -1, isElectricForceBlock: false, electricCharge: 0 }, negChargeTile));
            editorBlockPicker.appendChild(negChargeTile);

            let positiveElectricTile = document.createElement('div');
            positiveElectricTile.className = 'block-tile';
            positiveElectricTile.style.backgroundColor = 'red';
            positiveElectricTile.addEventListener('click', () => selectEditorBlock({ status: 1, hits: 1, isIndestructible: false, isChargeBlock: false, chargeChange: 0, isElectricForceBlock: true, electricCharge: 1, colorIndex: -1 }, positiveElectricTile));
            editorBlockPicker.appendChild(positiveElectricTile);
            
            let negativeElectricTile = document.createElement('div');
            negativeElectricTile.className = 'block-tile';
            negativeElectricTile.style.backgroundColor = 'blue';
            negativeElectricTile.addEventListener('click', () => selectEditorBlock({ status: 1, hits: 1, isIndestructible: false, isChargeBlock: false, chargeChange: 0, isElectricForceBlock: true, electricCharge: -1, colorIndex: -1 }, negativeElectricTile));
            editorBlockPicker.appendChild(negativeElectricTile);
            
            for (let r = 0; r < BASE_COLORS.length; r++) {
                for (let h = 1; h <= 3; h++) {
                    const tile = document.createElement('div');
                    tile.className = 'block-tile';
                    tile.style.backgroundColor = COLOR_PALETTE[r][h - 1];
                    tile.setAttribute('data-hits', h);
                    tile.setAttribute('data-color-index', r);
                    tile.setAttribute('data-status', '1');
                    tile.addEventListener('click', () => selectEditorBlock({ status: 1, hits: h, isIndestructible: false, isChargeBlock: false, chargeChange: 0, isElectricForceBlock: false, electricCharge: 0, colorIndex: r }, tile));
                    editorBlockPicker.appendChild(tile);
                }
            }
            const firstTile = editorBlockPicker.querySelector('.block-tile[data-hits="1"][data-color-index="0"]');
            if (firstTile) {
                selectEditorBlock({ status: 1, hits: 1, isIndestructible: false, isChargeBlock: false, chargeChange: 0, isElectricForceBlock: false, electricCharge: 0, colorIndex: 0 }, firstTile);
            }
        }

        function selectEditorBlock(block, element) {
            document.querySelectorAll('.block-tile').forEach(el => el.classList.remove('selected'));
            if (element) {
                element.classList.add('selected');
            }
            selectedBlock = {
                status: block.status,
                hits: block.hits || 0,
                isIndestructible: block.isIndestructible || false,
                isChargeBlock: block.isChargeBlock || false,
                chargeChange: block.chargeChange || 0,
                isElectricForceBlock: block.isElectricForceBlock || false,
                electricCharge: block.electricCharge || 0,
                colorIndex: block.colorIndex || 0
            };
        }

        async function toggleEditorMode() {
            editorMode = !editorMode;
            removeAllEventListeners();
            if (editorMode) {
                editorPanel.classList.remove('hidden');
                setupEditorBlockPicker();
                activateEditorEventListeners();
                gameStarted = false;
                lives = 3;
                score = 0;
            } else {
                editorPanel.classList.add('hidden');
                await restartGame();
                activateGameEventListeners();
            }
        }

        function editorMouseDownHandler(e) {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            startDragPos.x = e.clientX - rect.left;
            startDragPos.y = e.clientY - rect.top;
            isDragging = true;
            hasDragged = false;
        }

        function editorMouseMoveHandler(e) {
            if (!isDragging) return;
            hasDragged = true;
            const rect = canvas.getBoundingClientRect();
            endDragPos.x = e.clientX - rect.left;
            endDragPos.y = e.clientY - rect.top;
        }

        function editorMouseUpHandler(e) {
            if (!isDragging) return;
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const endDragX = e.clientX - rect.left;
            const endDragY = e.clientY - rect.top;
            endDragPos.x = endDragX;
            endDragPos.y = endDragY;

            let startC, endC, startR, endR;

            if (!hasDragged) {
                // Single click logic
                const mouseX = startDragPos.x;
                const mouseY = startDragPos.y;
                const c = Math.floor(mouseX / BLOCK_WIDTH);
                const r = Math.floor((mouseY - BLOCK_OFFSET_TOP) / BLOCK_HEIGHT);
                
                if (c >= 0 && c < BLOCK_COLUMN_COUNT && r >= 0 && r < BLOCK_ROW_COUNT) {
                    const blockIndex = c * BLOCK_ROW_COUNT + r;
                    const block = blocks[blockIndex];
                    if (block.status === 1) {
                        block.status = 0;
                    } else {
                        applyBlockProperties(block, selectedBlock);
                    }
                }
            } else {
                // Drag and drop logic
                startC = Math.floor(Math.min(startDragPos.x, endDragPos.x) / BLOCK_WIDTH);
                endC = Math.floor(Math.max(startDragPos.x, endDragPos.x) / BLOCK_WIDTH);
                startR = Math.floor((Math.min(startDragPos.y, endDragPos.y) - BLOCK_OFFSET_TOP) / BLOCK_HEIGHT);
                endR = Math.floor((Math.max(startDragPos.y, endDragPos.y) - BLOCK_OFFSET_TOP) / BLOCK_HEIGHT);
                
                startC = Math.max(0, startC);
                endC = Math.min(BLOCK_COLUMN_COUNT - 1, endC);
                startR = Math.max(0, startR);
                endR = Math.min(BLOCK_ROW_COUNT - 1, endR);

                for (let c = startC; c <= endC; c++) {
                    for (let r = startR; r <= endR; r++) {
                        const blockIndex = c * BLOCK_ROW_COUNT + r;
                        if (blockIndex >= 0 && blockIndex < blocks.length) {
                           applyBlockProperties(blocks[blockIndex], selectedBlock);
                        }
                    }
                }
            }

            isDragging = false;
            hasDragged = false;
            startDragPos = { x: 0, y: 0 };
            endDragPos = { x: 0, y: 0 };
        }
        
        function applyBlockProperties(block, properties) {
            block.status = properties.status; 
            
            if (block.status === 1) {
                block.isIndestructible = properties.isIndestructible;
                block.isChargeBlock = properties.isChargeBlock;
                block.chargeChange = properties.chargeChange;
                block.isElectricForceBlock = properties.isElectricForceBlock;
                block.electricCharge = properties.electricCharge;

                if (!block.isIndestructible && !block.isChargeBlock && !block.isElectricForceBlock) {
                    block.hits = properties.hits;
                    block.colorIndex = properties.colorIndex;
                    block.color = COLOR_PALETTE[block.colorIndex][block.hits - 1];
                } else if (block.isChargeBlock) {
                    block.hits = 100;
                    block.colorIndex = -1;
                    block.color = block.chargeChange > 0 ? 'rgba(255, 0, 0, 0.5)' : 'rgba(0, 0, 255, 0.5)';
                } else if (block.isElectricForceBlock) {
                    block.hits = 1;
                    block.colorIndex = -1;
                    block.color = block.electricCharge > 0 ? 'red' : 'blue';
                } else if (block.isIndestructible) {
                    block.hits = 100;
                    block.colorIndex = -1;
                    block.color = '#A9A9A9';
                }
            }
        }
        
        function saveStageToFile() {
            const stageData = blocks.map(block => {
                if (block.status === 0) {
                    return { status: 0 };
                }
                return {
                    status: 1,
                    hits: block.hits,
                    isIndestructible: block.isIndestructible,
                    isChargeBlock: block.isChargeBlock,
                    chargeChange: block.chargeChange,
                    isElectricForceBlock: block.isElectricForceBlock,
                    electricCharge: block.electricCharge,
                    colorIndex: block.colorIndex
                };
            });
            const dataStr = JSON.stringify(stageData);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `stage_${currentStageNumber.toString().padStart(2, '0')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function loadStageFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const stageData = JSON.parse(e.target.result);
                    if (stageData.length === blocks.length) {
                        blocks.forEach((block, index) => {
                            const savedBlock = stageData[index];
                            
                            block.status = savedBlock.status;
                            if (block.status === 1) {
                                block.hits = savedBlock.hits || 0;
                                block.isIndestructible = savedBlock.isIndestructible || false;
                                block.isChargeBlock = savedBlock.isChargeBlock || false;
                                block.chargeChange = savedBlock.chargeChange || 0;
                                block.isElectricForceBlock = savedBlock.isElectricForceBlock || false;
                                block.electricCharge = savedBlock.electricCharge || 0;
                                block.colorIndex = savedBlock.colorIndex || 0;
                                if (block.isChargeBlock) {
                                   block.color = block.chargeChange > 0 ? 'rgba(255, 0, 0, 0.5)' : 'rgba(0, 0, 255, 0.5)';
                                } else if (block.isElectricForceBlock) {
                                    block.color = block.electricCharge > 0 ? 'red' : 'blue';
                                } else if (block.isIndestructible) {
                                    block.color = '#A9A9A9';
                                } else {
                                    block.color = COLOR_PALETTE[block.colorIndex][block.hits - 1];
                                }
                            } else {
                                block.hits = 0;
                                block.isIndestructible = false;
                                block.isChargeBlock = false;
                                block.chargeChange = 0;
                                block.isElectricForceBlock = false;
                                block.electricCharge = 0;
                                block.colorIndex = -1;
                                block.color = '';
                            }
                        });
                        alert('ステージが読み込まれました！');
                    } else {
                        alert('無効なステージファイルです。');
                    }
                } catch (error) {
                    alert('ファイルの読み込みに失敗しました。');
                    console.error(error);
                }
            };
            reader.readAsText(file);
        }

        function keyDownHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = true;
                mouseTargetX = null;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = true;
                mouseTargetX = null;
            }
        }

        function keyUpHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = false;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = false;
            }
        }
        
        function mouseMoveHandler(e) {
            const rect = canvas.getBoundingClientRect();
            const relativeX = e.clientX - rect.left;
            if (relativeX > 0 && relativeX < CANVAS_WIDTH) {
                mouseTargetX = relativeX - paddle.width / 2;
            }
        }

        function touchStartHandler(e) {
            e.preventDefault();
            lastTouchX = e.touches[0].clientX - canvas.offsetLeft;
            touchActive = true;
        }
        
        function touchMoveHandler(e) {
            e.preventDefault();
            if (touchActive) {
                const currentTouchX = e.touches[0].clientX - canvas.offsetLeft;
                let targetX = paddle.x + (currentTouchX - lastTouchX);
                targetX = Math.max(0, Math.min(CANVAS_WIDTH - paddle.width, targetX));
                paddle.x = targetX;
                lastTouchX = currentTouchX;
            }
        }

        function touchEndHandler(e) {
            touchActive = false;
        }

        async function handleCanvasClick() {
            if (!gameStarted && !isTransitioningToNextStage) {
                if (lives > 0) {
                    if (blocks.length === BLOCK_COLUMN_COUNT * BLOCK_ROW_COUNT) {
                        startGame();
                    }
                } else {
                    await restartGame();
                }
            }
        }

        function resetBall(isLaunching) {
            balls = [];
            const newBall = {
                x: paddle.x + paddle.width / 2,
                y: paddle.y - BALL_RADIUS,
                radius: BALL_RADIUS,
                vx: 0,
                vy: 0,
                hitsOnPaddle: 0,
                charge: 0
            };
            if (isLaunching) {
                const angle = Math.PI / 2 + (Math.random() * 0.5 - 0.25);
                newBall.vx = BALL_SPEED_INITIAL * Math.cos(angle);
                newBall.vy = -BALL_SPEED_INITIAL * Math.sin(angle);
            }
            balls.push(newBall);
        }

        function startGame() {
            gameStarted = true;
            resetBall(true);
        }
        
        async function initBlocks() {
            blocks = [];
            const stageIndex = currentStageNumber - 1;
            const filename = `stage_${stageIndex.toString().padStart(2, '0')}.json`;
            
            try {
                const response = await fetch(filename);
                if (!response.ok) {
                    const errorMessage = `ステージファイル「${filename}」が見つかりません。ランダムステージを生成します。`;
                    throw new Error(errorMessage);
                }
                const stageData = await response.json();
                
                if (stageData.length !== BLOCK_COLUMN_COUNT * BLOCK_ROW_COUNT) {
                    throw new Error('無効なステージファイル形式です。');
                }

                stageData.forEach((savedBlock, index) => {
                    const c = Math.floor(index / BLOCK_ROW_COUNT);
                    const r = index % BLOCK_ROW_COUNT;
                    const blockX = c * BLOCK_WIDTH + BLOCK_OFFSET_LEFT;
                    const blockY = r * BLOCK_HEIGHT + BLOCK_OFFSET_TOP;
                    
                    const block = {
                        x: blockX,
                        y: blockY,
                        width: BLOCK_WIDTH,
                        height: BLOCK_HEIGHT,
                        status: savedBlock.status || 0,
                        hits: savedBlock.hits || 0,
                        isIndestructible: savedBlock.isIndestructible || false,
                        isChargeBlock: savedBlock.isChargeBlock || false,
                        chargeChange: savedBlock.chargeChange || 0,
                        isElectricForceBlock: savedBlock.isElectricForceBlock || false,
                        electricCharge: savedBlock.electricCharge || 0,
                        colorIndex: savedBlock.colorIndex || 0,
                        color: ''
                    };
                    
                    if (block.status === 1) {
                        if (block.isChargeBlock) {
                           block.color = block.chargeChange > 0 ? 'rgba(255, 0, 0, 0.5)' : 'rgba(0, 0, 255, 0.5)';
                        } else if (block.isElectricForceBlock) {
                            block.color = block.electricCharge > 0 ? 'red' : 'blue';
                        } else if (block.isIndestructible) {
                            block.color = '#A9A9A9';
                        } else {
                            block.color = COLOR_PALETTE[block.colorIndex][block.hits - 1];
                        }
                    } else {
                        block.color = '';
                    }
                    blocks.push(block);
                });
                console.log(`${filename} が正常に読み込まれました。`);

            } catch (error) {
                console.warn(error.message);
                for (let c = 0; c < BLOCK_COLUMN_COUNT; c++) {
                    for (let r = 0; r < BLOCK_ROW_COUNT; r++) {
                        const blockX = c * BLOCK_WIDTH + BLOCK_OFFSET_LEFT;
                        const blockY = r * BLOCK_HEIGHT + BLOCK_OFFSET_TOP;
                        const isIndestructible = Math.random() < 0.1;
                        const hits = isIndestructible ? 100 : Math.floor(Math.random() * 3) + 1;
                        const colorIndex = Math.floor(Math.random() * BASE_COLORS.length);
                        const color = isIndestructible ? '#A9A9A9' : COLOR_PALETTE[colorIndex][hits - 1];
                        
                        blocks.push({
                            x: blockX,
                            y: blockY,
                            width: BLOCK_WIDTH,
                            height: BLOCK_HEIGHT,
                            status: 1,
                            hits: hits,
                            isIndestructible: isIndestructible,
                            isChargeBlock: false,
                            chargeChange: 0,
                            isElectricForceBlock: false,
                            electricCharge: 0,
                            colorIndex: colorIndex,
                            color: color
                        });
                    }
                }
                console.log(`ステージ${currentStageNumber}をランダム生成しました。`);
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            if (!editorMode) {
                updatePaddle();
                if (gameStarted) {
                    updateBall();
                    collisionDetection();
                    updatePowerups();
                }
                drawGame();
            } else {
                drawEditor();
                if (isDragging) {
                    drawEditorPreview();
                }
            }
            requestAnimationFrame(draw);
        }

        function drawGame() {
            if (blocks.length !== BLOCK_COLUMN_COUNT * BLOCK_ROW_COUNT) {
                return;
            }

            drawPaddle();
            
            if (!gameStarted && balls.length > 0) {
                balls[0].x = paddle.x + paddle.width / 2;
                balls[0].y = paddle.y - balls[0].radius;
            }
            
            if (balls.length > 0) {
                drawBall();
            }
            drawBlocks();
            drawPowerups();
            drawScore();
            drawLives();
            drawStageNumber();

            if (!gameStarted) {
                if (lives <= 0) {
                    drawGameOver();
                } else {
                    drawStartScreen();
                }
            }
        }
        
        function drawEditor() {
            drawBlocks();
        }

        function drawEditorPreview() {
            const rect = canvas.getBoundingClientRect();
            
            let startC = Math.floor(Math.min(startDragPos.x, endDragPos.x) / BLOCK_WIDTH);
            let endC = Math.floor(Math.max(startDragPos.x, endDragPos.x) / BLOCK_WIDTH);
            let startR = Math.floor((Math.min(startDragPos.y, endDragPos.y) - BLOCK_OFFSET_TOP) / BLOCK_HEIGHT);
            let endR = Math.floor((Math.max(startDragPos.y, endDragPos.y) - BLOCK_OFFSET_TOP) / BLOCK_HEIGHT);

            startC = Math.max(0, startC);
            endC = Math.min(BLOCK_COLUMN_COUNT - 1, endC);
            startR = Math.max(0, startR);
            endR = Math.min(BLOCK_ROW_COUNT - 1, endR);

            const previewX = startC * BLOCK_WIDTH;
            const previewY = startR * BLOCK_HEIGHT + BLOCK_OFFSET_TOP;
            const previewWidth = (endC - startC + 1) * BLOCK_WIDTH;
            const previewHeight = (endR - startR + 1) * BLOCK_HEIGHT;
            
            if (previewWidth > 0 && previewHeight > 0 && previewY + previewHeight > BLOCK_OFFSET_TOP) {
                 ctx.globalAlpha = 0.5;
                 ctx.fillStyle = '#63b3ed';
                 ctx.fillRect(previewX, previewY, previewWidth, previewHeight);
                 ctx.globalAlpha = 1.0;
            }
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 8);
            ctx.fillStyle = '#a0aec0';
            ctx.fill();
            ctx.closePath();
        }

        function drawBall() {
            balls.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                
                const chargeIndex = b.charge + 3;
                const ballColor = BALL_COLORS[chargeIndex] || '#a0aec0';
                ctx.fillStyle = ballColor;

                ctx.fill();
                ctx.closePath();
            });
        }

        function drawBlocks() {
            const cornerRadius = 5;
            for (let c = 0; c < BLOCK_COLUMN_COUNT; c++) {
                for (let r = 0; r < BLOCK_ROW_COUNT; r++) {
                    const block = blocks[c * BLOCK_ROW_COUNT + r];
                    if (block.status === 1) {
                        let imageToDraw = null;
                        if (block.isIndestructible && !block.isChargeBlock) {
                            imageToDraw = unbreakableBlockImage;
                        } else if (block.isChargeBlock) {
                            imageToDraw = block.chargeChange > 0 ? posChargeAddBlockImage : negChargeAddBlockImage;
                        } else if (block.isElectricForceBlock) {
                            imageToDraw = block.electricCharge > 0 ? positiveBlockImage : negativeBlockImage;
                        }

                        if (imageToDraw && imageToDraw.complete && imageToDraw.naturalWidth > 0) {
                            ctx.drawImage(imageToDraw, block.x, block.y, block.width, block.height);
                        } else {
                            ctx.fillStyle = block.color;
                            ctx.beginPath();
                            ctx.roundRect(block.x, block.y, block.width, block.height, cornerRadius);
                            ctx.fill();
                            ctx.strokeStyle = '#1a202c';
                            ctx.lineWidth = 1;
                            ctx.stroke();
                            ctx.closePath();
                        }
                    }
                }
            }
        }

        function drawPowerups() {
            powerups.forEach(p => {
                ctx.beginPath();
                ctx.roundRect(p.x, p.y, p.size, p.size, 5);
                ctx.fillStyle = p.color;
                ctx.fill();
                ctx.closePath();
            });
        }

        function drawScore() {
            ctx.font = '16px "Inter"';
            ctx.fillStyle = '#e2e8f0';
            ctx.fillText('Score: ' + score, 8, 20);
        }

        function drawLives() {
            ctx.font = '16px "Inter"';
            ctx.fillStyle = '#e2e8f0';
            ctx.fillText('Lives: ' + lives, CANVAS_WIDTH - 80, 20);
        }

        function drawStageNumber() {
            ctx.font = '16px "Inter"';
            ctx.fillStyle = '#e2e8f0';
            ctx.textAlign = 'center';
            ctx.fillText(`Stage: ${currentStageNumber}`, CANVAS_WIDTH / 2, 20);
            ctx.textAlign = 'left';
        }

        function drawStartScreen() {
            ctx.font = '30px "Inter"';
            ctx.fillStyle = '#63b3ed';
            ctx.textAlign = 'center';
            ctx.fillText('クリック・タップ・上矢印でスタート', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
            ctx.font = '20px "Inter"';
            ctx.fillStyle = '#e2e8f0';
            ctx.fillText('左右矢印キー・マウス・スワイプでパドル操作', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            ctx.textAlign = 'left';
        }

        function drawGameOver() {
            ctx.font = '40px "Inter"';
            ctx.fillStyle = '#e53e3e';
            ctx.textAlign = 'center';
            ctx.fillText('ゲームオーバー', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
            ctx.font = '20px "Inter"';
            ctx.fillStyle = '#e2e8f0';
            ctx.fillText('スコア: ' + score, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            ctx.fillText('クリック・タップ・上矢印でリスタート', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 60);
            ctx.textAlign = 'left';
        }

        function drawWinScreen() {
            ctx.font = '40px "Inter"';
            ctx.fillStyle = '#48bb78';
            ctx.textAlign = 'center';
            if (currentStageNumber < TOTAL_STAGES) {
                ctx.fillText(`ステージ${currentStageNumber}クリア！`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
                ctx.font = '20px "Inter"';
                ctx.fillStyle = '#e2e8f0';
                ctx.fillText('次のステージへ', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            } else {
                ctx.fillText('Congratulations!!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
                ctx.font = '20px "Inter"';
                ctx.fillStyle = '#e2e8f0';
                ctx.fillText('ステージ1に戻ります', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            }
            ctx.textAlign = 'left';
        }

        async function restartGame() {
            balls = [];
            powerups = [];
            score = 0;
            lives = 3;
            currentStageNumber = 1;
            paddle.width = PADDLE_WIDTH_INITIAL;
            paddle.speed = PADDLE_SPEED_INITIAL;
            paddle.dx = 0;
            await initBlocks();
            gameStarted = false;
            resetBall(false);
        }

        function updatePaddle() {
            const prevPaddleX = paddle.x;
            
            if (mouseTargetX !== null) {
                const diff = mouseTargetX - paddle.x;
                const moveAmount = Math.sign(diff) * Math.min(Math.abs(diff), paddle.speed);
                paddle.x += moveAmount;
            } else if (rightPressed && paddle.x < CANVAS_WIDTH - paddle.width) {
                paddle.x += paddle.speed;
            } else if (leftPressed && paddle.x > 0) {
                paddle.x -= paddle.speed;
            }
            
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > CANVAS_WIDTH) paddle.x = CANVAS_WIDTH - paddle.width;
            
            paddle.dx = paddle.x - prevPaddleX;
        }

function updateBall() {
            const nextBalls = [];
            for (let i = 0; i < balls.length; i++) {
                const b = balls[i];
                
                const blockRadius = 6;
                const minC = Math.max(0, Math.floor((b.x - blockRadius * BLOCK_WIDTH) / BLOCK_WIDTH));
                const maxC = Math.min(BLOCK_COLUMN_COUNT - 1, Math.floor((b.x + blockRadius * BLOCK_WIDTH) / BLOCK_WIDTH));
                const minR = Math.max(0, Math.floor((b.y - blockRadius * BLOCK_HEIGHT) / BLOCK_HEIGHT));
                const maxR = Math.min(BLOCK_ROW_COUNT - 1, Math.floor((b.y + blockRadius * BLOCK_HEIGHT) / BLOCK_HEIGHT));

                for (let c = minC; c <= maxC; c++) {
                    for (let r = minR; r <= maxR; r++) {
                        const block = blocks[c * BLOCK_ROW_COUNT + r];
                        if (block.status === 1 && block.isElectricForceBlock) {
                            const blockCenterX = block.x + block.width / 2;
                            const blockCenterY = block.y + block.height / 2;
                            const dx = b.x - blockCenterX;
                            const dy = b.y - blockCenterY;
                            const distanceSq = dx * dx + dy * dy;

                            if (distanceSq < POSITIVE_BLOCK_RANGE_SQ && distanceSq > 0) {
                                const forceDirection = b.charge * block.electricCharge;
                                const forceMagnitude = POSITIVE_BLOCK_FORCE / distanceSq;
                                b.vx -= dx * forceMagnitude * forceDirection;
                                b.vy -= dy * forceMagnitude * forceDirection;
                            }
                        }
                    }
                }

                b.vy += GRAVITY;
                b.x += b.vx;
                b.y += b.vy;

                let currentSpeed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                if (currentSpeed > 0) {
                    let newSpeed;

                    if (b.x + b.radius > CANVAS_WIDTH) {
                        b.x = CANVAS_WIDTH - b.radius;
                        b.vx *= -1 * DAMPING_FACTOR;
                        newSpeed = Math.min(currentSpeed + collisionSpeedIncrement, MAX_BALL_SPEED);
                        const scaleFactor = newSpeed / currentSpeed;
                        b.vx *= scaleFactor;
                        b.vy *= scaleFactor;
                    }
                    if (b.x - b.radius < 0) {
                        b.x = b.radius;
                        b.vx *= -1 * DAMPING_FACTOR;
                        newSpeed = Math.min(currentSpeed + collisionSpeedIncrement, MAX_BALL_SPEED);
                        const scaleFactor = newSpeed / currentSpeed;
                        b.vx *= scaleFactor;
                        b.vy *= scaleFactor;
                    }
                    if (b.y - b.radius < 0) {
                        b.y = b.radius;
                        b.vy *= -1 * DAMPING_FACTOR;
                        newSpeed = Math.min(currentSpeed + collisionSpeedIncrement, MAX_BALL_SPEED);
                        const scaleFactor = newSpeed / currentSpeed;
                        b.vx *= scaleFactor;
                        b.vy *= scaleFactor;
                    }
                }

                if (
                    b.y + b.radius > paddle.y &&
                    b.y - b.radius < paddle.y + paddle.height &&
                    b.x + b.radius > paddle.x &&
                    b.x - b.radius < paddle.x + paddle.width
                ) {
                    if (b.vy > 0 && b.y < paddle.y + b.radius) {
                        b.y = paddle.y - b.radius;
                        b.hitsOnPaddle++;
                        
                        let newTargetSpeed;
                        if (b.hitsOnPaddle <= 10) {
                             newTargetSpeed = BALL_SPEED_INITIAL + b.hitsOnPaddle * speedIncrement;
                        } else {
                             newTargetSpeed = MAX_BALL_SPEED;
                        }

                        const hitPoint = (b.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
                        const clampedHitPoint = Math.max(-1, Math.min(1, hitPoint));
                        const baseVx = clampedHitPoint * newTargetSpeed * 0.8;
                        const paddleInfluence = 0.5;
                        let newVx = baseVx + paddle.dx * paddleInfluence;
                        newVx = Math.max(-newTargetSpeed, Math.min(newTargetSpeed, newVx));
                        let newVy = -Math.sqrt(newTargetSpeed * newTargetSpeed - newVx * newVx);
                        const minVyComponent = newTargetSpeed * 0.2;
                        if (isNaN(newVy) || Math.abs(newVy) < minVyComponent) {
                            newVy = -minVyComponent;
                            newVx = Math.sqrt(newTargetSpeed * newTargetSpeed - newVy * newVy) * (newVx < 0 ? -1 : 1);
                        }
                        b.vx = newVx;
                        b.vy = newVy;
                    }
                }

                if (b.y + b.radius > CANVAS_HEIGHT) {
                } else {
                    nextBalls.push(b);
                }

                currentSpeed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                if (currentSpeed > MAX_BALL_SPEED) {
                    b.vx = (b.vx / currentSpeed) * MAX_BALL_SPEED;
                    b.vy = (b.vy / currentSpeed) * MAX_BALL_SPEED;
                }
            }
            balls = nextBalls;
            if (balls.length === 0 && gameStarted) {
                lives--;
                if (lives > 0) {
                    gameStarted = false;
                    resetBall(false);
                } else {
                    gameStarted = false;
                }
            }
        }

function collisionDetection() {
            let allBlocksDestroyed = true;
            if (blocks.length !== BLOCK_COLUMN_COUNT * BLOCK_ROW_COUNT) {
                return;
            }
            
            for (let block of blocks) {
                if (block.status === 1 && !block.isIndestructible && !block.isChargeBlock) {
                    allBlocksDestroyed = false;
                    break;
                }
            }

            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                let hitThisFrame = false;

                // 衝突したブロックが複数あった場合、ボールを押し戻す方向を正しく決定するため、
                // 最もめり込み量が少ないブロックを探す
                let minOverlap = Infinity;
                let hitBlock = null;
                let overlapX = 0;
                let overlapY = 0;

                for (let c = 0; c < BLOCK_COLUMN_COUNT; c++) {
                    for (let r = 0; r < BLOCK_ROW_COUNT; r++) {
                        const block = blocks[c * BLOCK_ROW_COUNT + r];
                        if (block.status === 1) {
                            const rect = {
                                x: block.x,
                                y: block.y,
                                width: block.width,
                                height: block.height
                            };

                            const rectCenter = {
                                x: rect.x + rect.width / 2,
                                y: rect.y + rect.height / 2
                            };
                            
                            const dx = ball.x - rectCenter.x;
                            const dy = ball.y - rectCenter.y;
                            const clampedX = Math.max(rect.x, Math.min(ball.x, rect.x + rect.width));
                            const clampedY = Math.max(rect.y, Math.min(ball.y, rect.y + rect.height));

                            const distSq = (ball.x - clampedX) * (ball.x - clampedX) + (ball.y - clampedY) * (ball.y - clampedY);

                            if (distSq <= ball.radius * ball.radius) {
                                // 衝突が発生
                                const overlap_x = ball.radius + rect.width / 2 - Math.abs(dx);
                                const overlap_y = ball.radius + rect.height / 2 - Math.abs(dy);

                                if (Math.min(overlap_x, overlap_y) < minOverlap) {
                                    minOverlap = Math.min(overlap_x, overlap_y);
                                    hitBlock = block;
                                    overlapX = overlap_x;
                                    overlapY = overlap_y;
                                }
                            }
                        }
                    }
                }

                if (hitBlock) {
                    if (overlapX > overlapY) { // 上下で衝突
                        if (ball.y > hitBlock.y + hitBlock.height / 2) {
                            ball.y += overlapY;
                            ball.vy = Math.abs(ball.vy) * DAMPING_FACTOR;
                        } else {
                            ball.y -= overlapY;
                            ball.vy = -Math.abs(ball.vy) * DAMPING_FACTOR;
                        }
                    } else { // 左右で衝突
                        if (ball.x > hitBlock.x + hitBlock.width / 2) {
                            ball.x += overlapX;
                            ball.vx = Math.abs(ball.vx) * DAMPING_FACTOR;
                        } else {
                            ball.x -= overlapX;
                            ball.vx = -Math.abs(ball.vx) * DAMPING_FACTOR;
                        }
                    }

                    // ブロック衝突時の加速処理
                    const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                    if (currentSpeed > 0) {
                        const newSpeed = Math.min(currentSpeed + collisionSpeedIncrement, MAX_BALL_SPEED);
                        const scaleFactor = newSpeed / currentSpeed;
                        ball.vx *= scaleFactor;
                        ball.vy *= scaleFactor;
                    }

                    // ブロックのプロパティを更新
                    if (hitBlock.isChargeBlock) {
                        ball.charge = Math.max(-3, Math.min(3, ball.charge + hitBlock.chargeChange));
                    } else if (!hitBlock.isIndestructible) {
                        hitBlock.hits--;
                        if (hitBlock.hits <= 0) {
                            hitBlock.status = 0;
                            score += 10;
                            if (Math.random() < 0.3) {
                                const powerupTypes = ['paddle_enlarge', 'paddle_speedup'];
                                if (balls.length < BALL_MAX_COUNT) {
                                    powerupTypes.push('split_ball');
                                }
                                const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                                powerups.push({
                                    x: hitBlock.x + hitBlock.width / 2 - POWERUP_SIZE / 2,
                                    y: hitBlock.y + hitBlock.height / 2 - POWERUP_SIZE / 2,
                                    size: POWERUP_SIZE,
                                    color: (randomType === 'split_ball' ? '#ff00ff' : randomType === 'paddle_speedup' ? '#38a169' : '#ecc94b'),
                                    type: randomType
                                });
                            }
                        } else {
                            hitBlock.color = COLOR_PALETTE[hitBlock.colorIndex][hitBlock.hits - 1];
                        }
                    }
                    hitThisFrame = true;
                }
            }

            if (gameStarted && allBlocksDestroyed) {
                gameStarted = false;
                drawWinScreen();
                lives += 3;
                isTransitioningToNextStage = true;
                setTimeout(async () => {
                    if (currentStageNumber < TOTAL_STAGES) {
                        currentStageNumber++;
                    } else {
                        currentStageNumber = 1;
                    }
                    await initBlocks();
                    resetBall(false);
                    gameStarted = false;
                    isTransitioningToNextStage = false;
                }, 3000);
            }
        }

        function updatePowerups() {
            for (let i = powerups.length - 1; i >= 0; i--) {
                const p = powerups[i];
                p.y += POWERUP_SPEED;
                if (
                    p.y + p.size > paddle.y &&
                    p.y < paddle.y + paddle.height &&
                    p.x + p.size > paddle.x &&
                    p.x < paddle.x + paddle.width
                ) {
                    if (p.type === 'paddle_enlarge') {
                        paddle.width = Math.min(paddle.width + 30, CANVAS_WIDTH * 0.8);
                    } else if (p.type === 'split_ball') {
                        const ballsToAdd = [];
                        const currentBallsCount = balls.length;
                        let maxNewBalls = BALL_MAX_COUNT - currentBallsCount;
                        if (maxNewBalls > 0) {
                            for (let j = 0; j < currentBallsCount && maxNewBalls > 0; j++) {
                                const originalBall = balls[j];
                                const angleOffset = Math.PI / 10;
                                
                                ballsToAdd.push({
                                    x: originalBall.x,
                                    y: originalBall.y,
                                    radius: BALL_RADIUS,
                                    vx: BALL_SPEED_INITIAL * Math.cos(Math.atan2(originalBall.vy, originalBall.vx) + angleOffset),
                                    vy: BALL_SPEED_INITIAL * Math.sin(Math.atan2(originalBall.vy, originalBall.vx) + angleOffset),
                                    hitsOnPaddle: 0,
                                    charge: originalBall.charge
                                });
                                maxNewBalls--;
                                
                                if (maxNewBalls > 0) {
                                    ballsToAdd.push({
                                        x: originalBall.x,
                                        y: originalBall.y,
                                        radius: BALL_RADIUS,
                                        vx: BALL_SPEED_INITIAL * Math.cos(Math.atan2(originalBall.vy, originalBall.vx) - angleOffset),
                                        vy: BALL_SPEED_INITIAL * Math.sin(Math.atan2(originalBall.vy, originalBall.vx) - angleOffset),
                                        hitsOnPaddle: 0,
                                        charge: originalBall.charge
                                    });
                                    maxNewBalls--;
                                }
                            }
                            balls.push(...ballsToAdd);
                        }
                    } else if (p.type === 'paddle_speedup') {
                        paddle.speed = Math.min(paddle.speed + 2, PADDLE_SPEED_MAX);
                    }
                    powerups.splice(i, 1);
                }
                if (p.y > CANVAS_HEIGHT) {
                    powerups.splice(i, 1);
                }
            }
        }

        async function setupGame() {
            await initBlocks();
            resetBall(false);
            activateGameEventListeners();
            requestAnimationFrame(draw);
        }

        setupGame();
    </script>
</body>
</html>