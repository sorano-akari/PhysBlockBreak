<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>物理演算ブロック崩し</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a202c;
            color: #e2e8f0;
            margin: 0;
            overflow: hidden;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            border-radius: 16px;
            background-color: #2d3748;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        canvas {
            background-color: #2d3748;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            display: block;
            /* キャンバスにフォーカスリングを表示し、ユーザーにフォーカスが当たっていることを視覚的に伝える */
            outline: none;
        }
        h1 {
            margin-bottom: 20px;
            color: #63b3ed;
            font-size: 2.25rem;
            font-weight: bold;
        }
        /* フォーカス時のアウトラインを非表示にする（キャンバス以外） */
        *:focus {
            outline: none;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 tabindex="-1">物理演算ブロック崩し</h1>
        <canvas id="gameCanvas" tabindex="0"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ページロード時にキャンバスにフォーカスを合わせる
        document.addEventListener('DOMContentLoaded', () => {
            canvas.focus();
        });

        // クリック時にもキャンバスにフォーカスを合わせる
        document.addEventListener('click', () => {
            canvas.focus();
        });
        
        // キーボードのデフォルト動作（スクロールなど）を無効化
        document.addEventListener('keydown', (e) => {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });


        const CANVAS_WIDTH = 600;
        const CANVAS_HEIGHT = 450;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        const PADDLE_HEIGHT = 20;
        const PADDLE_WIDTH_INITIAL = 100;
        const PADDLE_SPEED_INITIAL = 5;
        const PADDLE_SPEED_MAX = 15;

        const BALL_RADIUS = 7;
        const BALL_SPEED_INITIAL = 5.0;
        const MAX_BALL_SPEED = 10.0;
        const GRAVITY = 0.04;
        const DAMPING_FACTOR = 0.99;
        const PADDLE_RESTITUTION_FACTOR = 1.5;

        const BLOCK_ROW_COUNT = 7;
        const BLOCK_COLUMN_COUNT = 10;
        const BLOCK_PADDING = 0;
        const BLOCK_WIDTH = CANVAS_WIDTH / BLOCK_COLUMN_COUNT;
        const BLOCK_HEIGHT = 20;
        const BLOCK_OFFSET_TOP = 20;
        const BLOCK_OFFSET_LEFT = 0;

        const POWERUP_SIZE = 20;
        const POWERUP_SPEED = 2;

        const ELECTROMAGNETIC_FORCE_CONSTANT = 0;

        let paddle = {
            x: (CANVAS_WIDTH - PADDLE_WIDTH_INITIAL) / 2,
            y: CANVAS_HEIGHT - PADDLE_HEIGHT - 30,
            width: PADDLE_WIDTH_INITIAL,
            height: PADDLE_HEIGHT,
            dx: 0,
            speed: PADDLE_SPEED_INITIAL
        };

        let balls = [];
        let blocks = [];
        let powerups = [];
        let score = 0;
        let lives = 3;
        let gameStarted = false;

        let rightPressed = false;
        let leftPressed = false;

        // キーイベントリスナーをcanvas自体に設定
        canvas.addEventListener('keydown', keyDownHandler, false);
        canvas.addEventListener('keyup', keyUpHandler, false);
        // マウスとタッチイベントは元々あったものをそのまま利用
        canvas.addEventListener('mousemove', mouseMoveHandler, false);
        canvas.addEventListener('click', handleCanvasClick, false);
        canvas.addEventListener('touchstart', touchStartHandler, false);
        canvas.addEventListener('touchmove', touchMoveHandler, false);
        canvas.addEventListener('touchend', touchEndHandler, false);

        // タップでもスタートできるように
        canvas.addEventListener('touchstart', function(e) { handleCanvasClick(); }, false);

        // スペースキーでもスタート・打ち出しできるように
        document.addEventListener('keydown', function(e) {
            if (!gameStarted && (e.code === 'Space' || e.key === ' ')) {
                if (lives > 0) startGame();
                else restartGame();
            }
        });

        let lastTouchX = 0;
        let touchActive = false;

        function keyDownHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = true;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = true;
            }
        }

        function keyUpHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = false;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = false;
            }
        }

        // マウス移動でパドルを一定速度で動かす
        function mouseMoveHandler(e) {
            const relativeX = e.clientX - canvas.offsetLeft;
            if (relativeX > 0 && relativeX < CANVAS_WIDTH) {
                let targetX = relativeX - paddle.width / 2;
                targetX = Math.max(0, Math.min(CANVAS_WIDTH - paddle.width, targetX));
                if (Math.abs(targetX - paddle.x) > paddle.speed) {
                    paddle.x += paddle.speed * Math.sign(targetX - paddle.x);
                } else {
                    paddle.x = targetX;
                }
            }
        }

        function touchStartHandler(e) {
            e.preventDefault();
            lastTouchX = e.touches[0].clientX - canvas.offsetLeft;
            touchActive = true;
        }

        // タッチ移動も一定速度で
        function touchMoveHandler(e) {
            e.preventDefault();
            if (touchActive) {
                const currentTouchX = e.touches[0].clientX - canvas.offsetLeft;
                let targetX = paddle.x + (currentTouchX - lastTouchX);
                targetX = Math.max(0, Math.min(CANVAS_WIDTH - paddle.width, targetX));
                if (Math.abs(targetX - paddle.x) > paddle.speed) {
                    paddle.x += paddle.speed * Math.sign(targetX - paddle.x);
                } else {
                    paddle.x = targetX;
                }
                lastTouchX = currentTouchX;
            }
        }

        function touchEndHandler(e) {
            touchActive = false;
        }

        function handleCanvasClick() {
            if (!gameStarted) {
                if (lives > 0) {
                    startGame();
                } else {
                    restartGame();
                }
            }
        }

        function resetBall(isLaunching) {
            balls = [];
            const newBall = {
                x: paddle.x + paddle.width / 2,
                y: paddle.y - BALL_RADIUS,
                radius: BALL_RADIUS,
                vx: 0,
                vy: 0,
                hitsOnPaddle: 0
            };
            if (isLaunching) {
                const angle = Math.PI / 2 + (Math.random() * 0.5 - 0.25);
                newBall.vx = BALL_SPEED_INITIAL * Math.cos(angle);
                newBall.vy = -BALL_SPEED_INITIAL * Math.sin(angle);
            }
            balls.push(newBall);
        }

        function startGame() {
            gameStarted = true;
            resetBall(true);
        }

        function initBlocks() {
            blocks = [];
            for (let c = 0; c < BLOCK_COLUMN_COUNT; c++) {
                for (let r = 0; r < BLOCK_ROW_COUNT; r++) {
                    const blockX = c * BLOCK_WIDTH + BLOCK_OFFSET_LEFT;
                    const blockY = r * BLOCK_HEIGHT + BLOCK_OFFSET_TOP;
                    const hits = Math.floor(Math.random() * 3) + 1;
                    let color;
                    switch (hits) {
                        case 1: color = '#4299e1'; break;
                        case 2: color = '#3182ce'; break;
                        case 3: color = '#2b6cb0'; break;
                        default: color = '#4299e1';
                    }
                    blocks.push({
                        x: blockX,
                        y: blockY,
                        width: BLOCK_WIDTH,
                        height: BLOCK_HEIGHT,
                        status: 1,
                        hits: hits,
                        isMagnetic: false,
                        color: color
                    });
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // updatePaddle() を drawPaddle() の前に呼び出すことで、
            // パドルの位置を更新してから描画する
            updatePaddle();

            drawPaddle();
            
            if (!gameStarted && balls.length > 0) {
                // パドルの位置が更新された後にボールの位置を同期させる
                balls[0].x = paddle.x + paddle.width / 2;
                balls[0].y = paddle.y - balls[0].radius;
            }

            if (balls.length > 0 && (gameStarted || (balls[0].vy === 0 && balls[0].vx === 0))) {
                drawBall();
            }
            drawBlocks();
            drawPowerups();
            drawScore();
            drawLives();

            if (gameStarted) {
                updateBall();
                collisionDetection();
                updatePowerups();
            }

            if (!gameStarted) {
                if (lives <= 0) {
                    drawGameOver();
                } else if (blocks.every(b => b.status === 0)) {
                    drawWinScreen();
                } else {
                    drawStartScreen();
                }
            }
            requestAnimationFrame(draw);
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 8);
            ctx.fillStyle = '#a0aec0';
            ctx.fill();
            ctx.closePath();
        }

        function drawBall() {
            balls.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#f6e05e';
                ctx.fill();
                ctx.closePath();
            });
        }

        function drawBlocks() {
            for (let c = 0; c < BLOCK_COLUMN_COUNT; c++) {
                for (let r = 0; r < BLOCK_ROW_COUNT; r++) {
                    const block = blocks[c * BLOCK_ROW_COUNT + r];
                    if (block.status === 1) {
                        ctx.beginPath();
                        ctx.roundRect(block.x, block.y, block.width, block.height, 5);
                        ctx.fillStyle = block.color;
                        ctx.fill();
                        ctx.strokeStyle = '#1a202c';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        ctx.closePath();
                    }
                }
            }
        }

        function drawPowerups() {
            powerups.forEach(p => {
                ctx.beginPath();
                ctx.roundRect(p.x, p.y, p.size, p.size, 5);
                ctx.fillStyle = p.color;
                ctx.fill();
                ctx.closePath();
            });
        }

        function drawScore() {
            ctx.font = '16px "Inter"';
            ctx.fillStyle = '#e2e8f0';
            ctx.fillText('Score: ' + score, 8, 20);
        }

        function drawLives() {
            ctx.font = '16px "Inter"';
            ctx.fillStyle = '#e2e8f0';
            ctx.fillText('Lives: ' + lives, CANVAS_WIDTH - 80, 20);
        }

        function drawStartScreen() {
            ctx.font = '30px "Inter"';
            ctx.fillStyle = '#63b3ed';
            ctx.textAlign = 'center';
            ctx.fillText('クリック・タップ・スペースでスタート', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
            ctx.font = '20px "Inter"';
            ctx.fillStyle = '#e2e8f0';
            ctx.fillText('矢印キー・マウス・スワイプでパドル操作', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            ctx.textAlign = 'left';
        }

        function drawGameOver() {
            ctx.font = '40px "Inter"';
            ctx.fillStyle = '#e53e3e';
            ctx.textAlign = 'center';
            ctx.fillText('ゲームオーバー', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
            ctx.font = '20px "Inter"';
            ctx.fillStyle = '#e2e8f0';
            ctx.fillText('スコア: ' + score, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            ctx.fillText('クリック・タップ・スペースでリスタート', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 60);
            ctx.textAlign = 'left';
        }

        function drawWinScreen() {
            ctx.font = '40px "Inter"';
            ctx.fillStyle = '#48bb78';
            ctx.textAlign = 'center';
            ctx.fillText('ゲームクリア！', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 20);
            ctx.font = '20px "Inter"';
            ctx.fillStyle = '#e2e8f0';
            ctx.fillText('スコア: ' + score, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
            ctx.fillText('クリック・タップ・スペースでリスタート', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 60);
            ctx.textAlign = 'left';
        }

        function restartGame() {
            score = 0;
            lives = 3;
            paddle.width = PADDLE_WIDTH_INITIAL;
            paddle.speed = PADDLE_SPEED_INITIAL;
            initBlocks();
            powerups = [];
            gameStarted = false;
            resetBall(false);
        }

        // パドルの位置を更新（矢印キーでスタート前も動かせる）
        function updatePaddle() {
            const prevPaddleX = paddle.x;
            if (rightPressed && paddle.x < CANVAS_WIDTH - paddle.width) {
                paddle.x += paddle.speed;
            } else if (leftPressed && paddle.x > 0) {
                paddle.x -= paddle.speed;
            }
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > CANVAS_WIDTH) paddle.x = CANVAS_WIDTH - paddle.width;
            paddle.dx = paddle.x - prevPaddleX;
        }

        function updateBall() {
            const nextBalls = [];
            for (let i = 0; i < balls.length; i++) {
                const b = balls[i];
                blocks.forEach(block => {
                    if (block.status === 1 && block.isMagnetic) {
                        const blockCenterX = block.x + block.width / 2;
                        const blockCenterY = block.y + block.height / 2;
                        const dx = blockCenterX - b.x;
                        const dy = blockCenterY - b.y;
                        const distanceSq = dx * dx + dy * dy;
                        const minDistanceSq = (block.width / 2 + b.radius) * (block.width / 2 + b.radius);
                        const effectiveDistanceSq = Math.max(distanceSq, minDistanceSq);
                        const forceMagnitude = ELECTROMAGNETIC_FORCE_CONSTANT / effectiveDistanceSq;
                        b.vx += dx * forceMagnitude;
                        b.vy += dy * forceMagnitude;
                    }
                });
                b.vy += GRAVITY;
                b.x += b.vx;
                b.y += b.vy;

                if (b.x + b.radius > CANVAS_WIDTH) {
                    b.x = CANVAS_WIDTH - b.radius;
                    b.vx *= -1 * DAMPING_FACTOR;
                }
                if (b.x - b.radius < 0) {
                    b.x = b.radius;
                    b.vx *= -1 * DAMPING_FACTOR;
                }
                if (b.y - b.radius < 0) {
                    b.y = b.radius;
                    b.vy *= -1 * DAMPING_FACTOR;
                }

                if (
                    b.y + b.radius > paddle.y &&
                    b.y - b.radius < paddle.y + paddle.height &&
                    b.x + b.radius > paddle.x &&
                    b.x - b.radius < paddle.x + paddle.width
                ) {
                    if (b.vy > 0 && b.y < paddle.y + b.radius) {
                        b.y = paddle.y - b.radius;
                        b.hitsOnPaddle++;
                        const speedIncrement = (MAX_BALL_SPEED - BALL_SPEED_INITIAL) / 10;
                        let newTargetSpeed;
                        if (b.hitsOnPaddle <= 10) {
                             newTargetSpeed = BALL_SPEED_INITIAL + b.hitsOnPaddle * speedIncrement;
                        } else {
                             newTargetSpeed = MAX_BALL_SPEED;
                        }

                        const hitPoint = (b.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
                        const clampedHitPoint = Math.max(-1, Math.min(1, hitPoint));
                        const baseVx = clampedHitPoint * newTargetSpeed * 0.8;
                        const paddleInfluence = 0.5;
                        let newVx = baseVx + paddle.dx * paddleInfluence;
                        newVx = Math.max(-newTargetSpeed, Math.min(newTargetSpeed, newVx));
                        let newVy = -Math.sqrt(newTargetSpeed * newTargetSpeed - newVx * newVx);
                        const minVyComponent = newTargetSpeed * 0.2;
                        if (isNaN(newVy) || Math.abs(newVy) < minVyComponent) {
                            newVy = -minVyComponent;
                            newVx = Math.sqrt(newTargetSpeed * newTargetSpeed - newVy * newVy) * (newVx < 0 ? -1 : 1);
                        }
                        b.vx = newVx;
                        b.vy = newVy;
                    }
                }

                if (b.y + b.radius > CANVAS_HEIGHT) {
                    // ボール消失
                } else {
                    nextBalls.push(b);
                }

                const currentSpeed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                if (currentSpeed > MAX_BALL_SPEED) {
                    b.vx = (b.vx / currentSpeed) * MAX_BALL_SPEED;
                    b.vy = (b.vy / currentSpeed) * MAX_BALL_SPEED;
                }
            }
            balls = nextBalls;
            if (balls.length === 0 && gameStarted) {
                lives--;
                if (lives > 0) {
                    gameStarted = false;
                    resetBall(false);
                } else {
                    gameStarted = false;
                }
            }
        }

        function collisionDetection() {
            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                let hitThisFrame = false;
                for (let c = 0; c < BLOCK_COLUMN_COUNT; c++) {
                    for (let r = 0; r < BLOCK_ROW_COUNT; r++) {
                        const block = blocks[c * BLOCK_ROW_COUNT + r];
                        if (block.status === 1) {
                            const testX = Math.max(block.x, Math.min(ball.x, block.x + block.width));
                            const testY = Math.max(block.y, Math.min(ball.y, block.y + block.height));
                            const distX = ball.x - testX;
                            const distY = ball.y - testY;
                            const distance = Math.sqrt((distX * distX) + (distY * distY));
                            if (distance <= ball.radius) {
                                block.hits--;
                                if (block.hits <= 0) {
                                    block.status = 0;
                                    score += 10;
                                } else {
                                    switch (block.hits) {
                                        case 1: block.color = '#4299e1'; break;
                                        case 2: block.color = '#3182ce'; break;
                                        default: block.color = '#2b6cb0';
                                    }
                                }
                                // パワーアップ追加（加速アイテムも追加）
                                if (Math.random() < 0.3 && block.status === 0) {
                                    const powerupTypes = ['paddle_enlarge', 'split_ball', 'paddle_speedup'];
                                    const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                                    powerups.push({
                                        x: block.x + block.width / 2 - POWERUP_SIZE / 2,
                                        y: block.y + block.height / 2 - POWERUP_SIZE / 2,
                                        size: POWERUP_SIZE,
                                        color: (randomType === 'split_ball' ? '#ff00ff' : randomType === 'paddle_speedup' ? '#38a169' : '#ecc94b'),
                                        type: randomType
                                    });
                                }
                                const overlapX = ball.radius - Math.abs(distX);
                                const overlapY = ball.radius - Math.abs(distY);
                                if (overlapX > overlapY) {
                                    ball.vy *= -1;
                                    ball.y += ball.vy;
                                } else {
                                    ball.vx *= -1;
                                    ball.x += ball.vx;
                                }
                                hitThisFrame = true;
                                break;
                            }
                        }
                    }
                    if (hitThisFrame) break;
                }
            }
        }

        function updatePowerups() {
            for (let i = powerups.length - 1; i >= 0; i--) {
                const p = powerups[i];
                p.y += POWERUP_SPEED;
                if (
                    p.y + p.size > paddle.y &&
                    p.y < paddle.y + paddle.height &&
                    p.x + p.size > paddle.x &&
                    p.x < paddle.x + paddle.width
                ) {
                    if (p.type === 'paddle_enlarge') {
                        paddle.width = Math.min(paddle.width + 30, CANVAS_WIDTH * 0.8);
                    } else if (p.type === 'split_ball') {
                        const ballsToAdd = [];
                        const currentBallsCount = balls.length;
                        for (let j = 0; j < currentBallsCount; j++) {
                            const originalBall = balls[j];
                            const angleOffset = Math.PI / 10;
                            ballsToAdd.push({
                                x: originalBall.x,
                                y: originalBall.y,
                                radius: BALL_RADIUS,
                                vx: BALL_SPEED_INITIAL * Math.cos(Math.atan2(originalBall.vy, originalBall.vx) + angleOffset),
                                vy: BALL_SPEED_INITIAL * Math.sin(Math.atan2(originalBall.vy, originalBall.vx) + angleOffset),
                                hitsOnPaddle: 0
                            });
                            ballsToAdd.push({
                                x: originalBall.x,
                                y: originalBall.y,
                                radius: BALL_RADIUS,
                                vx: BALL_SPEED_INITIAL * Math.cos(Math.atan2(originalBall.vy, originalBall.vx) - angleOffset),
                                vy: BALL_SPEED_INITIAL * Math.sin(Math.atan2(originalBall.vy, originalBall.vx) - angleOffset),
                                hitsOnPaddle: 0
                            });
                        }
                        balls.push(...ballsToAdd);
                    } else if (p.type === 'paddle_speedup') {
                        paddle.speed = Math.min(paddle.speed + 2, PADDLE_SPEED_MAX);
                    }
                    powerups.splice(i, 1);
                }
                if (p.y > CANVAS_HEIGHT) {
                    powerups.splice(i, 1);
                }
            }
        }

        initBlocks();
        resetBall(false);
        requestAnimationFrame(draw);
    </script>
</body>
</html>